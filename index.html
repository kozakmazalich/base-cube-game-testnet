<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Base Cube Game - Win $BASE</title>
  
  <!-- Farcaster Frame Meta Tags for Base.dev -->
  <meta property="fc:frame" content="vNext" />
  <meta property="fc:frame:image" content="https://i.imgur.com/6wX7Z2y.png" />
  <meta property="fc:frame:button:1" content="Roll Cube" />
  <meta property="fc:frame:post_url" content="https://your-app.com/api/frame" />
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background: #0a0e17;
      overflow: hidden;
      position: relative;
      font-family: system-ui, -apple-system, sans-serif;
      gap: 60px;
      padding: 20px;
    }

    /* Пиксельный фон с цветами Base.org */
    .pixel-bg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      display: grid;
      grid-template-columns: repeat(40, 1fr);
      grid-template-rows: repeat(40, 1fr);
      gap: 2px;
      padding: 10px;
    }

    .pixel {
      background: rgba(0, 82, 255, 0.05);
      border-radius: 1px;
      aspect-ratio: 1/1;
      animation: pixelGlow 12s infinite ease-in-out;
    }

    @keyframes pixelGlow {
      0%, 85% {
        background: rgba(0, 82, 255, 0.05);
        box-shadow: 0 0 1px rgba(0, 82, 255, 0);
      }
      90% {
        background: rgba(0, 82, 255, 0.3);
        box-shadow: 0 0 6px rgba(255, 255, 255, 0.8);
      }
      95% {
        background: rgba(255, 255, 255, 0.6);
        box-shadow: 0 0 8px rgba(255, 255, 255, 1);
      }
      100% {
        background: rgba(0, 82, 255, 0.05);
        box-shadow: 0 0 1px rgba(0, 82, 255, 0);
      }
    }

    .scene {
      width: 200px;
      height: 200px;
      perspective: 1000px;
    }

    .cube {
      width: 100%;
      height: 100%;
      position: relative;
      transform-style: preserve-3d;
      transform: rotateX(15deg) rotateY(15deg);
    }

    .face {
      position: absolute;
      width: 200px;
      height: 200px;
      border-radius: 12px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 60px;
      font-weight: 700;
      color: white;
      text-shadow: 0 2px 10px rgba(0,0,0,0.3);
      box-shadow: 
        0 0 25px rgba(0, 82, 255, 0.6),
        inset 0 0 40px rgba(255, 255, 255, 0.15);
      background: linear-gradient(135deg, rgba(0, 82, 255, 0.9) 0%, rgba(0, 112, 255, 0.9) 100%);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .front  { transform: rotateY(0deg) translateZ(100px); }
    .back   { transform: rotateY(180deg) translateZ(100px); }
    .right  { transform: rotateY(90deg) translateZ(100px); }
    .left   { transform: rotateY(-90deg) translateZ(100px); }
    .top    { transform: rotateX(90deg) translateZ(100px); }
    .bottom { transform: rotateX(-90deg) translateZ(100px); }

    /* Кнопка Roll с цветами Base.org */
    .roll-btn {
      padding: 16px 40px;
      font-size: 18px;
      font-weight: 600;
      background: linear-gradient(135deg, #0052FF 0%, #0070FF 100%);
      color: white;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      box-shadow: 0 10px 25px rgba(0, 82, 255, 0.4);
      transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1);
      position: relative;
      overflow: hidden;
      letter-spacing: 0.5px;
      margin-top: 30px;
    }

    .roll-btn:hover {
      transform: translateY(-4px);
      box-shadow: 0 15px 30px rgba(0, 82, 255, 0.6);
      background: linear-gradient(135deg, #0070FF 0%, #0088FF 100%);
    }

    .roll-btn:active {
      transform: translateY(2px);
      box-shadow: 0 5px 15px rgba(0, 82, 255, 0.4);
    }

    .roll-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
      transition: left 0.6s;
    }

    .roll-btn:hover::before {
      left: 100%;
    }

    .roll-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    /* Wallet Connect Button */
    .connect-btn {
      padding: 12px 24px;
      font-size: 16px;
      font-weight: 600;
      background: linear-gradient(135deg, #0052FF 0%, #0070FF 100%);
      color: white;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      box-shadow: 0 8px 20px rgba(0, 82, 255, 0.3);
      transition: all 0.3s ease;
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 1000;
    }

    .connect-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 12px 25px rgba(0, 82, 255, 0.5);
    }

    .connect-btn.connected {
      background: linear-gradient(135deg, #00C851 0%, #00E676 100%);
      box-shadow: 0 8px 20px rgba(0, 200, 81, 0.3);
    }

    /* Game Mode Indicator */
    .game-mode {
      position: absolute;
      top: 80px;
      left: 20px;
      background: rgba(0, 82, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 16px;
      padding: 10px 15px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      color: white;
      font-size: 12px;
      box-shadow: 0 4px 15px rgba(0, 82, 255, 0.2);
      z-index: 1000;
    }

    .mode-onchain {
      color: #00E676;
      font-weight: 600;
    }

    .mode-simulation {
      color: #FFD700;
      font-weight: 600;
    }

    /* Салют с цветами Base.org */
    .firework {
      position: absolute;
      pointer-events: none;
      z-index: 100;
    }

    .particle {
      position: absolute;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      animation: firework 1.5s ease-out forwards;
    }

    @keyframes firework {
      0% {
        transform: translate(0, 0) scale(1);
        opacity: 1;
      }
      50% {
        opacity: 1;
      }
      100% {
        transform: translate(var(--tx), var(--ty)) scale(0);
        opacity: 0;
      }
    }

    .win-glow {
      animation: winGlow 2s ease-in-out;
    }

    @keyframes winGlow {
      0%, 100% {
        box-shadow: 
          0 0 25px rgba(0, 82, 255, 0.6),
          inset 0 0 40px rgba(255, 255, 255, 0.15);
      }
      50% {
        box-shadow: 
          0 0 50px rgba(255, 255, 255, 0.9),
          0 0 80px rgba(0, 82, 255, 0.8),
          inset 0 0 60px rgba(255, 255, 255, 0.4);
      }
    }

    /* Таблица наград */
    .rewards-table {
      background: rgba(0, 82, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 16px;
      padding: 25px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      box-shadow: 0 10px 30px rgba(0, 82, 255, 0.2);
      min-width: 250px;
    }

    .rewards-table h3 {
      color: white;
      text-align: center;
      margin-bottom: 20px;
      font-size: 20px;
      font-weight: 600;
    }

    .reward-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      color: white;
    }

    .reward-item:last-child {
      border-bottom: none;
    }

    .reward-symbol {
      font-size: 24px;
      margin-right: 15px;
    }

    .reward-text {
      flex: 1;
      font-size: 16px;
      font-weight: 500;
    }

    .reward-tokens {
      background: linear-gradient(135deg, #0052FF, #0070FF);
      padding: 4px 12px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: 600;
    }

    .game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .game-cost {
      color: white;
      font-size: 14px;
      margin-top: 10px;
      opacity: 0.8;
    }

    .token-balance {
      position: absolute;
      top: 20px;
      right: 20px;
      z-index: 1000;
      background: rgba(0, 82, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 16px;
      padding: 15px 20px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      color: white;
      font-size: 14px;
      box-shadow: 0 8px 25px rgba(0, 82, 255, 0.2);
      text-align: center;
    }

    .balance {
      font-weight: 600;
      margin-top: 5px;
      color: #FFD700;
    }

    .transaction-status {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 82, 255, 0.9);
      color: white;
      padding: 12px 24px;
      border-radius: 25px;
      font-weight: 600;
      z-index: 1000;
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 25px rgba(0, 82, 255, 0.4);
      text-align: center;
      max-width: 400px;
    }

    /* Mobile responsiveness */
    @media (max-width: 768px) {
      body {
        flex-direction: column;
        gap: 30px;
        padding: 10px;
      }
      
      .scene {
        width: 150px;
        height: 150px;
      }
      
      .face {
        width: 150px;
        height: 150px;
        font-size: 40px;
      }
      
      .front  { transform: rotateY(0deg) translateZ(75px); }
      .back   { transform: rotateY(180deg) translateZ(75px); }
      .right  { transform: rotateY(90deg) translateZ(75px); }
      .left   { transform: rotateY(-90deg) translateZ(75px); }
      .top    { transform: rotateX(90deg) translateZ(75px); }
      .bottom { transform: rotateX(-90deg) translateZ(75px); }
      
      .rewards-table {
        min-width: 200px;
        padding: 15px;
      }
      
      .connect-btn {
        position: relative;
        top: 0;
        left: 0;
        margin-bottom: 20px;
      }
      
      .game-mode {
        position: relative;
        top: 0;
        left: 0;
        margin-bottom: 10px;
      }
    }
  </style>
</head>
<body>
  <button class="connect-btn" id="connectBtn">Connect Wallet</button>
  <div class="game-mode" id="gameMode">Mode: <span class="mode-simulation">Simulation</span></div>

  <div class="token-balance">
    <div>$BASE Balance: <span id="tokenBalance">0</span></div>
    <div class="balance">Wallet: <span id="walletAddress">Not connected</span></div>
  </div>

  <div class="rewards-table">
    <h3>Rewards</h3>
    <div class="reward-item">
      <span class="reward-symbol">💎</span>
      <span class="reward-text">1 base token</span>
      <span class="reward-tokens">+1</span>
    </div>
    <div class="reward-item">
      <span class="reward-symbol">⭐</span>
      <span class="reward-text">3 base tokens</span>
      <span class="reward-tokens">+3</span>
    </div>
    <div class="reward-item">
      <span class="reward-symbol">🏆</span>
      <span class="reward-text">5 base tokens</span>
      <span class="reward-tokens">+5</span>
    </div>
  </div>

  <div class="game-container">
    <div class="scene">
      <div class="cube" id="cube">
        <div class="face front">🏆</div>
        <div class="face back">❌</div>
        <div class="face right">💎</div>
        <div class="face left">⭐</div>
        <div class="face top">❌</div>
        <div class="face bottom">❌</div>
      </div>
    </div>

    <button class="roll-btn" id="rollBtn">ROLL</button>
    <div class="game-cost">Free to play!</div>
  </div>

  <div class="pixel-bg" id="pixelBg"></div>
  <div class="firework" id="firework"></div>

  <!-- Ethers.js for blockchain interaction -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  
  <script>
    // Wait for Ethers.js to load before initializing
    function checkEthersLoaded() {
      if (typeof ethers === 'undefined') {
        console.error('Ethers.js not loaded yet');
        setTimeout(checkEthersLoaded, 100);
        return;
      }
      console.log('Ethers.js loaded successfully');
      initializeBaseApp();
    }

    // Contract addresses for Base Sepolia
    const TOKEN_CONTRACT_ADDRESS = "0x3C307A3dDfB4B2B1f67eBD5E17A751488572F72c";
    const GAME_CONTRACT_ADDRESS = "0x6B7CA86362c0C3BE01B23Ef03a2c2Cb17692c0f4";
    
    // Base Sepolia network configuration
    const BASE_SEPOLIA_CHAIN_ID = '0x14a34';
    const BASE_SEPOLIA_RPC_URL = 'https://sepolia.base.org';
    
    // Game Configuration
    const TOKEN_REWARDS = {
      '⭐': 1,
      '💎': 3,
      '🏆': 5
    };

    // DOM Elements
    const tokenBalanceElement = document.getElementById('tokenBalance');
    const walletAddressElement = document.getElementById('walletAddress');
    const rollBtn = document.getElementById('rollBtn');
    const connectBtn = document.getElementById('connectBtn');
    const gameModeElement = document.getElementById('gameMode');

    let userTokenBalance = 0;
    let provider;
    let signer;
    let tokenContract;
    let gameContract;
    let userAddress;
    let isOnChainMode = false;

    // ABI for ERC20 token (simplified)
    const tokenAbi = [
      "function balanceOf(address) view returns (uint256)",
      "function transfer(address to, uint256 amount) returns (bool)",
      "function decimals() view returns (uint8)",
      "function symbol() view returns (string)"
    ];

    // ABI for game contract (simplified) - Updated with common game functions
    const gameAbi = [
      "function playGame() returns (uint256)",
      "function rollDice() returns (uint256)",
      "function spinWheel() returns (uint256)",
      "function claimReward() returns (uint256)",
      "function getLastResult(address) view returns (uint256)",
      "function userBalance(address) view returns (uint256)",
      "function claimRewards()",
      "function isGameActive() view returns (bool)"
    ];

    // Initialize for Base Sepolia environment
    async function initializeBaseApp() {
      console.log('Initializing Base Cube Game on Base Sepolia...');
      console.log('Ethers version:', ethers?.version);
      
      await setupGame();
    }

    async function setupGame() {
      // Show transaction status
      function showTransactionStatus(message) {
        // Remove existing status
        const existingStatus = document.querySelector('.transaction-status');
        if (existingStatus) {
          existingStatus.remove();
        }
        
        const status = document.createElement('div');
        status.className = 'transaction-status';
        status.textContent = message;
        document.body.appendChild(status);
        
        // Auto remove after 5 seconds
        setTimeout(() => {
          if (status.parentNode) {
            status.remove();
          }
        }, 5000);
      }

      // Update game mode display
      function updateGameMode() {
        if (isOnChainMode) {
          gameModeElement.innerHTML = 'Mode: <span class="mode-onchain">On-Chain</span>';
        } else {
          gameModeElement.innerHTML = 'Mode: <span class="mode-simulation">Simulation</span>';
        }
      }

      // Test contract connection
      async function testContractConnection() {
        try {
          // Test if we can read from the contract
          const isActive = await gameContract.isGameActive().catch(() => false);
          const userBal = await gameContract.userBalance(userAddress).catch(() => 0);
          
          console.log('Contract test - isActive:', isActive, 'userBalance:', userBal);
          return true;
        } catch (error) {
          console.log('Contract test failed, using simulation mode:', error.message);
          return false;
        }
      }

      // Connect wallet function
      async function connectWallet() {
        try {
          // Check if Ethers.js is available
          if (typeof ethers === 'undefined') {
            showTransactionStatus('Error: Ethers.js library not loaded. Please refresh the page.');
            return;
          }

          if (typeof window.ethereum === 'undefined') {
            showTransactionStatus('Please install MetaMask to play!');
            // Enable roll button for simulation mode
            rollBtn.disabled = false;
            return;
          }

          showTransactionStatus('Connecting to wallet...');
          
          // Request account access
          const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
          
          // Check if we're on Base Sepolia
          const chainId = await window.ethereum.request({ method: 'eth_chainId' });
          
          if (chainId !== BASE_SEPOLIA_CHAIN_ID) {
            try {
              // Switch to Base Sepolia
              await window.ethereum.request({
                method: 'wallet_switchEthereumChain',
                params: [{ chainId: BASE_SEPOLIA_CHAIN_ID }],
              });
            } catch (switchError) {
              // If the network hasn't been added to MetaMask
              if (switchError.code === 4902) {
                await window.ethereum.request({
                  method: 'wallet_addEthereumChain',
                  params: [
                    {
                      chainId: BASE_SEPOLIA_CHAIN_ID,
                      chainName: 'Base Sepolia',
                      rpcUrls: [BASE_SEPOLIA_RPC_URL],
                      nativeCurrency: {
                        name: 'Ether',
                        symbol: 'ETH',
                        decimals: 18,
                      },
                      blockExplorerUrls: ['https://sepolia.basescan.org'],
                    },
                  ],
                });
              } else {
                throw switchError;
              }
            }
          }

          // Initialize ethers provider
          provider = new ethers.providers.Web3Provider(window.ethereum);
          signer = provider.getSigner();
          userAddress = await signer.getAddress();
          
          // Initialize contracts
          tokenContract = new ethers.Contract(TOKEN_CONTRACT_ADDRESS, tokenAbi, signer);
          gameContract = new ethers.Contract(GAME_CONTRACT_ADDRESS, gameAbi, signer);
          
          // Update UI
          connectBtn.textContent = 'Connected';
          connectBtn.classList.add('connected');
          walletAddressElement.textContent = `${userAddress.substring(0, 6)}...${userAddress.substring(userAddress.length - 4)}`;
          rollBtn.disabled = false;
          
          // Test contract connection
          const contractWorks = await testContractConnection();
          isOnChainMode = contractWorks;
          updateGameMode();
          
          if (contractWorks) {
            showTransactionStatus('Wallet connected! On-chain mode activated.');
            // Load user balance from contract
            await loadUserBalance();
          } else {
            showTransactionStatus('Wallet connected! Using simulation mode.');
          }
          
          // Set up event listeners for account and chain changes
          window.ethereum.on('accountsChanged', handleAccountsChanged);
          window.ethereum.on('chainChanged', handleChainChanged);
          
        } catch (error) {
          console.error('Error connecting wallet:', error);
          showTransactionStatus('Error connecting wallet: ' + (error.message || 'Unknown error'));
          // Enable simulation mode even if connection fails
          rollBtn.disabled = false;
        }
      }

      function handleAccountsChanged(accounts) {
        if (accounts.length === 0) {
          // User disconnected their wallet
          disconnectWallet();
        } else {
          // User switched accounts
          userAddress = accounts[0];
          walletAddressElement.textContent = `${userAddress.substring(0, 6)}...${userAddress.substring(userAddress.length - 4)}`;
          loadUserBalance();
        }
      }

      function handleChainChanged(chainId) {
        // Reload the page when chain changes
        window.location.reload();
      }

      function disconnectWallet() {
        connectBtn.textContent = 'Connect Wallet';
        connectBtn.classList.remove('connected');
        walletAddressElement.textContent = 'Not connected';
        tokenBalanceElement.textContent = '0';
        rollBtn.disabled = false; // Keep roll enabled for simulation
        userTokenBalance = 0;
        userAddress = null;
        isOnChainMode = false;
        updateGameMode();
      }

      // Load user token balance
      async function loadUserBalance() {
        try {
          if (signer && tokenContract) {
            const balance = await tokenContract.balanceOf(userAddress);
            const decimals = await tokenContract.decimals();
            userTokenBalance = parseFloat(ethers.utils.formatUnits(balance, decimals));
            tokenBalanceElement.textContent = userTokenBalance.toFixed(2);
          }
        } catch (error) {
          console.error("Error loading user balance:", error);
        }
      }

      // Try different game functions
      async function tryGameFunctions() {
        const functions = ['playGame', 'rollDice', 'spinWheel', 'claimReward'];
        
        for (const funcName of functions) {
          try {
            console.log(`Trying ${funcName}...`);
            const tx = await gameContract[funcName]();
            showTransactionStatus(`Transaction submitted (${funcName})...`);
            
            const receipt = await tx.wait();
            console.log(`${funcName} successful:`, receipt);
            
            // Try to get result
            const result = await gameContract.getLastResult(userAddress).catch(() => 0);
            return { success: true, function: funcName, result: result };
          } catch (error) {
            console.log(`${funcName} failed:`, error.message);
            continue;
          }
        }
        
        return { success: false };
      }

      // Process game rewards
      async function processGameResult(winningSymbol) {
        try {
          if (isOnChainMode && gameContract && signer) {
            showTransactionStatus('Processing game on-chain...');
            
            // Try different game functions
            const result = await tryGameFunctions();
            
            if (result.success) {
              if (result.result > 0) {
                userTokenBalance += parseInt(result.result);
                tokenBalanceElement.textContent = userTokenBalance.toFixed(2);
                showTransactionStatus(`🎉 You won ${result.result} $BASE tokens!`);
              } else {
                showTransactionStatus('Better luck next time! ❌');
              }
            } else {
              // If all contract calls fail, fall back to simulation
              throw new Error('All contract functions failed');
            }
          } else {
            // Simulation mode
            showTransactionStatus('Processing game result...');
            
            setTimeout(() => {
              if (winningSymbol === '❌') {
                showTransactionStatus('Better luck next time! ❌');
              } else {
                const tokensWon = TOKEN_REWARDS[winningSymbol];
                userTokenBalance += tokensWon;
                tokenBalanceElement.textContent = userTokenBalance.toFixed(2);
                showTransactionStatus(`🎉 You won ${tokensWon} $BASE tokens! +${tokensWon} $BASE added to your balance`);
              }
            }, 2000);
          }
          
        } catch (error) {
          console.error('Error processing game:', error);
          // Fall back to simulation mode
          isOnChainMode = false;
          updateGameMode();
          
          setTimeout(() => {
            if (winningSymbol === '❌') {
              showTransactionStatus('Better luck next time! ❌');
            } else {
              const tokensWon = TOKEN_REWARDS[winningSymbol];
              userTokenBalance += tokensWon;
              tokenBalanceElement.textContent = userTokenBalance.toFixed(2);
              showTransactionStatus(`🎉 Simulation: Won ${tokensWon} $BASE tokens!`);
            }
          }, 2000);
        }
      }

      // Connect wallet button event listener
      connectBtn.addEventListener('click', connectWallet);

      // Initialize simulation mode by default
      updateGameMode();
      rollBtn.disabled = false;

      // Пиксельный фон
      const pixelBg = document.getElementById('pixelBg');
      const pixelCount = 1600;
      
      for (let i = 0; i < pixelCount; i++) {
        const pixel = document.createElement('div');
        pixel.classList.add('pixel');
        
        const animationDelay = Math.random() * 15;
        const animationDuration = 10 + Math.random() * 8;
        
        pixel.style.animationDelay = `${animationDelay}s`;
        pixel.style.animationDuration = `${animationDuration}s`;
        
        pixelBg.appendChild(pixel);
      }

      // Game Logic
      const cube = document.getElementById('cube');
      const firework = document.getElementById('firework');
      
      let isSpinning = false;
      
      // Fixed positions - only 3 winning symbols, 3 losing symbols
      const winSymbols = ['⭐', '💎', '🏆'];
      const stopPositions = [
        { x: 0, y: 0, z: 0, symbol: '🏆' },      // фронт - WIN
        { x: 0, y: 180, z: 0, symbol: '❌' },    // зад - LOSE
        { x: 90, y: 0, z: 0, symbol: '❌' },     // верх - LOSE
        { x: -90, y: 0, z: 0, symbol: '❌' },    // низ - LOSE
        { x: 0, y: 90, z: 0, symbol: '💎' },     // право - WIN
        { x: 0, y: -90, z: 0, symbol: '⭐' }      // лево - WIN
      ];
      
      // Функция создания салюта с цветами Base.org
      function createFirework(x, y) {
        const colors = ['#0052FF', '#0070FF', '#FFFFFF', '#0088FF', '#E6F0FF', '#B3D4FF'];
        
        for (let i = 0; i < 60; i++) {
          const particle = document.createElement('div');
          particle.classList.add('particle');
          
          const angle = Math.random() * Math.PI * 2;
          const distance = 80 + Math.random() * 120;
          const tx = Math.cos(angle) * distance;
          const ty = Math.sin(angle) * distance;
          const color = colors[Math.floor(Math.random() * colors.length)];
          const size = 3 + Math.random() * 4;
          const duration = 1 + Math.random() * 0.5;
          
          particle.style.left = `${x}px`;
          particle.style.top = `${y}px`;
          particle.style.width = `${size}px`;
          particle.style.height = `${size}px`;
          particle.style.background = color;
          particle.style.setProperty('--tx', `${tx}px`);
          particle.style.setProperty('--ty', `${ty}px`);
          particle.style.animationDuration = `${duration}s`;
          
          firework.appendChild(particle);
          
          setTimeout(() => {
            particle.remove();
          }, duration * 1000);
        }
      }
      
      // Функция для запуска салюта со всех сторон
      function createVictoryFireworks() {
        const positions = [
          [window.innerWidth * 0.1, window.innerHeight * 0.1],
          [window.innerWidth * 0.9, window.innerHeight * 0.1],
          [window.innerWidth * 0.1, window.innerHeight * 0.9],
          [window.innerWidth * 0.9, window.innerHeight * 0.9],
          [window.innerWidth * 0.5, window.innerHeight * 0.1],
          [window.innerWidth * 0.5, window.innerHeight * 0.9],
          [window.innerWidth * 0.1, window.innerHeight * 0.5],
          [window.innerWidth * 0.9, window.innerHeight * 0.5],
          [window.innerWidth * 0.3, window.innerHeight * 0.3],
          [window.innerWidth * 0.7, window.innerHeight * 0.3],
          [window.innerWidth * 0.3, window.innerHeight * 0.7],
          [window.innerWidth * 0.7, window.innerHeight * 0.7]
        ];
        
        positions.forEach(([x, y], index) => {
          setTimeout(() => {
            createFirework(x, y);
          }, index * 150);
        });
      }
      
      function spinCube() {
        if (isSpinning) return;
        
        isSpinning = true;
        rollBtn.disabled = true;
        
        // Случайное направление и скорость вращения
        const startX = Math.random() * 360;
        const startY = Math.random() * 360;
        
        // Случайная конечная позиция
        const finalPos = stopPositions[Math.floor(Math.random() * stopPositions.length)];
        
        let startTime = null;
        const totalDuration = 4000;
        const spinDuration = 3000;
        
        function animate(currentTime) {
          if (!startTime) startTime = currentTime;
          const elapsed = currentTime - startTime;
          const progress = Math.min(elapsed / totalDuration, 1);
          
          if (progress < 0.75) {
            // Активное вращение
            const spinProgress = Math.min(elapsed / spinDuration, 1);
            const easeOut = 1 - Math.pow(1 - spinProgress, 3);
            
            const currentX = startX + (720 * easeOut);
            const currentY = startY + (720 * easeOut);
            
            cube.style.transform = `rotateX(${currentX}deg) rotateY(${currentY}deg)`;
          } else {
            // Замедление
            const slowProgress = (progress - 0.75) / 0.25;
            const easeInOut = slowProgress < 0.5 ? 
              2 * slowProgress * slowProgress : 
              1 - Math.pow(-2 * slowProgress + 2, 2) / 2;
            
            const currentX = finalPos.x * easeInOut;
            const currentY = finalPos.y * easeInOut;
            
            cube.style.transform = `rotateX(${currentX}deg) rotateY(${currentY}deg)`;
          }
          
          if (progress < 1) {
            requestAnimationFrame(animate);
          } else {
            // Завершение анимации
            cube.style.transform = `rotateX(${finalPos.x}deg) rotateY(${finalPos.y}deg)`;
            
            const isWinSymbol = winSymbols.includes(finalPos.symbol);
            
            if (isWinSymbol) {
              const faces = cube.getElementsByClassName('face');
              for (let face of faces) {
                if (face.textContent === finalPos.symbol) {
                  face.classList.add('win-glow');
                  
                  // Process win
                  processGameResult(finalPos.symbol);
                  createVictoryFireworks();
                  
                  setTimeout(() => {
                    face.classList.remove('win-glow');
                  }, 2000);
                  break;
                }
              }
            } else {
              // Process loss
              processGameResult('❌');
            }
            
            isSpinning = false;
            rollBtn.disabled = false;
         
